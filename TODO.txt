TODO:
 o make Set capable of handling more than ints
	 x maybe using templates
	 o this could enable:
		 x real numbers (I THINK THIS IS A CHECK)
		 x vectors / higer dimensional sets
		 o quotients
		 ? strings?
	 o variables inside of sets ( eg. {...-2k, -1k, 0, 1k, 2k...}
 o intervals
	 - (), (], [), []
 o more ways of generating
	 ? something that would work for real numbers
		 o i know how to improve this, maybe using newtons method or changing the grain.
			really easy to do for function support
	 o functions
	 o sequences
 o operations
	 o Set union, intersection, difference
		 o might need multiple rules, so behaviour would need to be added for that
	 o arithmetic
 o interpreter
	 o input stream
		 x figure out notation
		 x tokenizer
		 o text editor? or just in console for now
	 o output stream
		 o dynamic output
		 o graphing capability?
			 o how to show complex numbers, higher dimensional numbers, real numbers
			 o i want to be able to graph the mandlebrot set in less than 50 characters
				M := {c @ `C : |z_N| < N, z_(i+1) := z_i^2 + c, z_0 := 0}, N -> `inf 

example phrases:
	S := {x @ !C : |x| < 3}
	S = (-3, 3)				TRUE
	S = [-3, 3)				FALSE
	S - 1					(-4, 2)
	S - 1 ;= -3 (0.1)		[-3.1, -2.9]
	~ X @ `R : X < 1000000	LIKELY until it searches 1000001, FALSE
							if i properly program expressions, maybe will show false immediately

UNUSED: &
//	TODO: TOKENS		//
//	END_PHRASE,			// \n (normally)
//	BEGIN_PRIORITY,		// (
//	END_PRIORITY,		// )
//						//
//	BEGIN_SET,			// {
//	END_SET,			// }
//	BEGIN_NOT_INCLUSIVE,// (
//	END_NOT_INCLUSIVE,	// )
//	BEGIN_INCLUSIVE,	// [
//	END_INCLUSICE,		// ]
//	ELEMENT_OF,			// @
//	SUCH_THAT,			// :
//	ETC,				// ... tries to use proportionality to
//						//	deduce rule, always polynomial
//	PRINT,				// $, use variants for graphing i think
//	ACCESS,				// ` used for mathematical constants and stuff, `inf, `R, `C, `pi, `e
//	SUB,				// _ used for sequences
//						//	maybe for classes or something later
//	THERE_EXISTS,		// ?
//	FOR_ALL,			// ~
//						//
//	VARIABLE,			// any string of upper/lower, potentially
//						//	ending in a number
//	DEFINE,				// :=
//						//
//	LITERAL_INTEGER,	//
//	LITERAL_BOOLEAN,	//
//	LITERAL_STRING,		//
//	LITERAL_REAL,		//
//	LITERAL_PROBABILITY //
//						//
//						//
//	POSITIVE,			// + S, + x
//	ABSOLUTE,			// |x|, |S|
//						//
//	DYADS,				//
//						//
//	EQUAL,				// =
//	NOT_EQUAL,			// !=
//	LESS,				// <
//	GREATER,			// >
//	LESS_OR_EQUAL,		// <=
//	GREATER_OR_EQUAL,	// >=
//						//
//	ADD,				// S + x, x + y (S + S is union)
//	SUBTRACT,			// S - x, x - y (S - S is difference)
//	probability???		// x | x
//	MULTIPLY,			// *
//	DIVIDE,				// /
//	MODULO,				// %
//	LENGTH,				// #
//	POWER,				// ^
//						//
//	VARIANT,			// ; affects next operator to change something
//						//	about it
//						//	arg1 ;op arg2 (flags, ...)
//						//	eg. 2 ;= 2.05 (0.1) would return true,
//						//	because ; makes it an aproximate variant
//						//	eg. 0 ;+ 10 (i, i^2) = 0 + 1 + 4 + 9 + 16...
//						//	because ;+ is a sum		start ;+ end (w respect to, function)